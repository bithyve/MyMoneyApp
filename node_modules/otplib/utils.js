/**
 * otplib-utils
 *
 * @author Gerald Yeo <contact@fusedthought.com>
 * @version: 10.0.1
 * @license: MIT
 **/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function hexToInt(hex) {
  return parseInt(hex, 16);
}

function intToHex(value) {
  return parseInt(value, 10).toString(16);
}

function isValidToken(value) {
  return /^(\d+)(\.\d+)?$/.test(value);
}
function isSameToken(token1, token2) {
  if (isValidToken(token1) && isValidToken(token2)) {
    return String(token1) === String(token2);
  }
  return false;
}

function leftPad(value, length) {
  const total = !length ? 0 : length;
  let padded = value + '';
  while (padded.length < total) {
    padded = '0' + padded;
  }
  return padded;
}

function padSecret(secretBuffer, size, encoding) {
  const secret = secretBuffer.toString(encoding);
  const len = secret.length;
  if (size && len < size) {
    const newSecret = new Array(size - len + 1).join(
      secretBuffer.toString('hex')
    );
    return new Buffer(newSecret, 'hex').slice(0, size);
  }
  return secretBuffer;
}

function removeSpaces(value = '') {
  if (value == null) {
    return '';
  }
  return value.replace(/\s+/g, '');
}

function secretKey(length, options = {}) {
  if (!length || length < 1) {
    return '';
  }
  if (!options.crypto || typeof options.crypto.randomBytes !== 'function') {
    throw new Error('Expecting options.crypto to have a randomBytes function');
  }
  return options.crypto
    .randomBytes(length)
    .toString('base64')
    .slice(0, length);
}

function setsOf(value, amount = 4, divider = ' ') {
  const num = parseInt(amount, 10);
  if (Number.isNaN(num) || typeof value !== 'string') {
    return '';
  }
  const regex = new RegExp('.{1,' + amount + '}', 'g');
  return value.match(regex).join(divider);
}

function stringToHex(value) {
  const val = value == null ? '' : value;
  let hex = '';
  let tmp = '';
  for (let i = 0; i < val.length; i++) {
    tmp = ('0000' + val.charCodeAt(i).toString(16)).slice(-2);
    hex += '' + tmp;
  }
  return hex;
}

exports.hexToInt = hexToInt;
exports.intToHex = intToHex;
exports.isSameToken = isSameToken;
exports.leftPad = leftPad;
exports.padSecret = padSecret;
exports.removeSpaces = removeSpaces;
exports.secretKey = secretKey;
exports.setsOf = setsOf;
exports.stringToHex = stringToHex;
